{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["settings","Application","this","width","height","wrapper","document","querySelector","canvas","createElement","appendChild","context","getContext","canvasOverlay","contextOverlay","resize","window","addEventListener","universe","Universe","render","clearRect","devicePixelRatio","gradient","createRadialGradient","light","position","x","y","addColorStop","fillStyle","fillRect","boxes","boxArray","i","length","box","color","strokeStyle","shadowCorners","j","beginPath","moveTo","corners","lineTo","closePath","stroke","fill","sides","arc","Math","PI","update","requestAnimationFrame","center","innerWidth","innerHeight","style","generateBoxes","globalCompositeOperation","speed","Light","Box","push","centerPixel","dx","dy","Array","prototype","forEach","call","random","radius","rotation","rotationSpeed","floor","getRandomColor","getCornerLocations","getShadowCorners","internalAngle","sin","cos","dist","sqrt","onload","s","app","e","clientX","clientY","state","App","className","id","title","src","frameborder","allowfullscreen","display","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.bbb3f55c.chunk.js","sourcesContent":["import './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <div id=\"game-wrapper\"></div>\r\n      <iframe title=\"uniq\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/73n7HTcmb5g?autoplay=1\" frameborder=\"0\" allowfullscreen style={{display:\"none\"}}></iframe>\r\n    </div>\r\n  );\r\n}\r\n\r\n// This is a long one. I hope this over-commenting helps. Let's do this!\r\n\r\n// Let's put our settings up top so we can change them easily\r\nlet settings = {\r\n  spotlightRadius: 400,\r\n  boxCount: 50,\r\n  moveSpeed: 1,\r\n  turboSpeed: 5,\r\n}\r\n\r\n// Let's define our states, there's only one in this game at the moment\r\nfunction state(s){\r\n  // we call our init state all the way down the bottom of our code\r\n  if (s===\"init\"){\r\n    // let's create an instance of our class Application\r\n    const app = new Application();\r\n\r\n    // Add our UI\r\n    let wrapper = document.querySelector('#game-wrapper');\r\n    // update light position\r\n    wrapper.addEventListener('mousemove',function(e){\r\n      app.universe.light.position.x = e.clientX*window.devicePixelRatio;\r\n      app.universe.light.position.y = e.clientY*window.devicePixelRatio;\r\n    });\r\n    // engage turbo when our mouse is down\r\n    wrapper.addEventListener('mousedown',() => {\r\n      app.universe.speed = settings.turboSpeed;\r\n    });\r\n    // release turbo when mouse is up\r\n    wrapper.addEventListener('mouseup',()=>{\r\n      app.universe.speed = settings.moveSpeed;\r\n    });\r\n  }\r\n}\r\n\r\n// This is our application class. It contains our Universe which contains our Boxes and our Light\r\n// I called them boxes, not crystals, because this project changed direction as it progressed\r\nclass Application {\r\n  constructor(){\r\n    // Our app has a width and a height\r\n    // wWe don't know their size yet but we can figure them out using the resize function below\r\n    this.width = null;\r\n    this.height = null;\r\n\r\n    let wrapper = document.querySelector('#game-wrapper');\r\n    // Let's create our canvas that the game will be rendered on\r\n    this.canvas = document.createElement('canvas');\r\n    // and put it inside of our wrapper\r\n    wrapper.appendChild(this.canvas);\r\n    // create a context for it that we will render into, it's a 2d sim\r\n    this.context = this.canvas.getContext('2d');\r\n\r\n    // We'll also need a masking canvas to hide crystals ourside of the lit area\r\n    // It's the black outside of our visible ring, we'll call it an overlay\r\n    this.canvasOverlay = document.createElement('canvas');\r\n    wrapper.appendChild(this.canvasOverlay);\r\n    this.contextOverlay = this.canvasOverlay.getContext('2d');\r\n\r\n    // Let's resize our canvas\r\n    this.resize();\r\n    // and set up a listener which will resize it again if the window size changes\r\n    window.addEventListener('resize', () => this.resize(), false);\r\n\r\n    // if you haven't come across this \"() => foo()\":\r\n    // It's just a condensed way of writing \"function() {foo()}\"\r\n    // read here: https://babeljs.io/learn-es2015/\r\n\r\n    // Let's add our Universe class to our app and pass through the width and height values\r\n    this.universe = new Universe(this.width,this.height);\r\n\r\n    // and start our render function\r\n    this.render();\r\n  }\r\n\r\n  render(){\r\n    // Canvases need to be cleared each frame or else what you draw will just layer on top\r\n    // So let's clear the whole canvas\r\n    this.context.clearRect(0,0,this.width*window.devicePixelRatio,this.height*window.devicePixelRatio);\r\n\r\n    // Let's fill in the \"lit\" area around our mouse with a nice gradien so the light looks like it fades away\r\n    // First let's create our gradient\r\n    let gradient=this.context.createRadialGradient(this.universe.light.position.x,this.universe.light.position.y,0.9*settings.spotlightRadius,this.universe.light.position.x,this.universe.light.position.y,0);\r\n    // ... and pass through our hex colors\r\n    gradient.addColorStop(0,\"#202062\");\r\n    gradient.addColorStop(1,\"#988280\");\r\n\r\n    // Now let's add this gradient to our canvas context\r\n    this.context.fillStyle = gradient;\r\n    this.context.fillRect(0,0,this.width,this.height);\r\n\r\n    // Now let's draw the boxes from our universe\r\n    // They exist in the universe, but everything is rendered in our app's render step\r\n    let boxes = this.universe.boxArray;\r\n    // create a for loop that goes through our box array\r\n    for (var i=0; i<boxes.length;i++){\r\n      //  and pulls out each box one at a time\r\n      let box = boxes[i];\r\n\r\n      // Let's draw this crystal\r\n      // -----------------------\r\n      // First let's get it's color\r\n      this.context.fillStyle = box.color;\r\n      this.context.strokeStyle = box.color;\r\n      // For each side of the crystal we'll have to project that side into the distance:\r\n      // Notice that each point on a crystal casts a \"shadow\" that extends away from where a mouse is\r\n      // So for each point on this box let's do that\r\n      for (let i = 0;i<box.shadowCorners.length;i++){\r\n        // shade by section between this point and the next point and then the shadow\r\n        // and loop back to the start if we're at our final point (to close the shape)\r\n        let j = (i<box.shadowCorners.length-1) ? i+1:0\r\n\r\n        // Let's project the side of our crystal off into the distance by creating a polygon\r\n        // this is tricky to describe but maybe this will help imgur.com/a/84048\r\n        this.context.beginPath();\r\n        this.context.moveTo(box.corners[i].x,box.corners[i].y);\r\n        this.context.lineTo(box.shadowCorners[i].x,box.shadowCorners[i].y);\r\n        this.context.lineTo(box.shadowCorners[j].x,box.shadowCorners[j].y);\r\n        this.context.lineTo(box.corners[j].x,box.corners[j].y);\r\n\r\n        // close out path, fill and stroke and \r\n        this.context.closePath();\r\n        this.context.stroke();\r\n        this.context.fill();\r\n\r\n        // We repeat this process for every side of every crystal :o computers are so cool\r\n      }\r\n\r\n      // Okay but we've still got to draw the happy box over the top of this mess\r\n      this.context.beginPath();\r\n      // fortunately this is just one shape\r\n      this.context.moveTo(box.corners[0].x,box.corners[0].y);\r\n      for (let i = 1;i<box.sides;i++){\r\n        this.context.lineTo(box.corners[i].x,box.corners[i].y);\r\n      }\r\n      this.context.closePath();\r\n      this.context.fill();\r\n      this.context.stroke();\r\n    }\r\n\r\n    // Let's paint a little happy circle in where our mouse is\r\n    // Remember, this is your universe, you don't have to do this\r\n    // Just make it up as you go... (RIP Bob Ross)\r\n    this.context.beginPath();\r\n    this.context.arc(this.universe.light.position.x,this.universe.light.position.y,2,0,2*Math.PI);\r\n    this.context.stroke();\r\n\r\n    // Now let's draw our overlay\r\n    // First let's clear the old one\r\n    this.contextOverlay.clearRect(0,0,this.width*window.devicePixelRatio,this.height*window.devicePixelRatio);\r\n\r\n    // We want a transparent circle centered around our mouse\r\n    // rimmed with the color that our light fades out to\r\n    gradient=this.contextOverlay.createRadialGradient(this.universe.light.position.x,this.universe.light.position.y,settings.spotlightRadius,this.universe.light.position.x,this.universe.light.position.y,0);\r\n    gradient.addColorStop(0,\"#0a0e23\");\r\n    gradient.addColorStop(0.5,\"transparent\");\r\n\r\n    // Try commenting out these lines to see it without the overlay\r\n    this.contextOverlay.fillStyle = gradient;\r\n    this.contextOverlay.fillRect(0,0,this.width,this.height);\r\n\r\n    // Now update the position of everything in our universe\r\n    this.update();\r\n\r\n    // And request another render frame\r\n    window.requestAnimationFrame(()=>this.render());\r\n  }\r\n\r\n  update(){\r\n    this.universe.update(this.center);\r\n  }\r\n\r\n  resize(){\r\n    // Set our app width and height to that of the window\r\n    this.width = window.innerWidth;\r\n    this.height = window.innerHeight;\r\n\r\n    // And resize our wrapper to these dimensions\r\n    document.querySelector('#game-wrapper').style.width = this.width+'px';\r\n    document.querySelector('#game-wrapper').style.height = this.height+'px';\r\n\r\n    // Then get the size for our canvas based off the pixel density of the screen\r\n    this.width *= window.devicePixelRatio;\r\n    this.height *= window.devicePixelRatio;\r\n\r\n    // and resize our canvases\r\n    this.canvas.width = this.width;\r\n    this.canvas.height = this.height;\r\n    this.canvasOverlay.width = this.width;\r\n    this.canvasOverlay.height = this.height;\r\n\r\n    // regenerate our boxes\r\n    if (this.universe) this.universe.generateBoxes();\r\n\r\n    // BLEND MODE\r\n    // this will mix the colors of the crystals as they are laid over the top of one another\r\n    this.context.globalCompositeOperation = 'screen';\r\n\r\n    // And define our center pixel\r\n    this.center = {\r\n      x: this.width/2,\r\n      y: this.height/2\r\n    }\r\n  }\r\n}\r\n\r\n// Our Universe class contains our light and our Boxes (crystals)\r\nclass Universe{\r\n  constructor(width,height){\r\n    // It inherits the width and height of our app\r\n    this.width = width;\r\n    this.height = height;\r\n    this.speed = settings.moveSpeed;\r\n\r\n    // Let's store all of the boxes in our universe in an array for nice access\r\n    this.boxArray = [];\r\n\r\n    // generate our Boxes\r\n    this.generateBoxes();\r\n\r\n    // And also add the light which hangs out on our mouse\r\n    this.light = new Light(width*.75,height*.35);\r\n  }\r\n\r\n  generateBoxes(){\r\n    // Clear array if there is one\r\n    this.boxArray = [];\r\n    // Let's create the number of boxes we defined in our settings\r\n    for (let i=0;i<settings.boxCount;i++){\r\n      // create a box\r\n      let box = new Box(this.width, this.height);\r\n      // and add it to our array of boxes\r\n      this.boxArray.push(box);\r\n    }\r\n  }\r\n\r\n  // This is called alongside each render frame \r\n  update(centerPixel){\r\n    // First we calculate our change in direction based on where the mouse is \r\n    // the further it is from the center, the more we move in that direction\r\n    // Our change in x\r\n    let dx = (centerPixel.x - this.light.position.x)/100;\r\n    // and our change in y\r\n    let dy = (centerPixel.y - this.light.position.y)/100;\r\n\r\n    // Now we can use this change to update our box positions and their shadows\r\n    Array.prototype.forEach.call(this.boxArray, (box)=>{\r\n      box.update(centerPixel,dx*this.speed,dy*this.speed,this.light);\r\n    });\r\n  }\r\n}\r\n\r\n// Each box is a crystal\r\nclass Box {\r\n  constructor(width,height){\r\n    // When it's created let's give it a random position inside of the width and height of our universe\r\n    this.position = {\r\n      x: Math.random()*width,\r\n      y: Math.random()*height,\r\n    }\r\n    // and give it a random radius\r\n    this.radius = Math.random()*30;\r\n    // a random rotation\r\n    this.rotation = Math.random();\r\n    // a random rotation speed\r\n    this.rotationSpeed = (Math.random()-0.5)/100;\r\n    // a random number of sides\r\n    // (min 3 sides max 8)\r\n    this.sides = Math.floor(Math.random()*6+3);\r\n    // and a random color using the getRandomColor function below\r\n    this.color = this.getRandomColor();\r\n\r\n    // let's create an array for each box to store the location of it's corners and the projection of those corners away from our light source\r\n    this.corners = [];\r\n    // and let's figure out those locations\r\n    this.getCornerLocations();\r\n    this.shadowCorners = this.corners;\r\n  }\r\n\r\n  update(centerPixel,dx,dy,light){\r\n    // update the box position\r\n    this.position.x += dx;\r\n    this.position.y += dy;\r\n\r\n    // check location of our box and loop it if it's outside of canvas \r\n    if (this.position.x<-this.radius){\r\n      this.position.x+=centerPixel.x*2+this.radius*2;\r\n    } else if (this.position.x>centerPixel.x*2+this.radius){\r\n      this.position.x -= centerPixel.x*2+this.radius*2;\r\n    }\r\n    if (this.position.y<0-this.radius){\r\n      this.position.y+=centerPixel.y*2+this.radius*2;\r\n    } else if (this.position.y>centerPixel.y*2+this.radius){\r\n      this.position.y-=centerPixel.y*2+this.radius*2;\r\n    }\r\n\r\n    // rotate the box according to it's speed\r\n    this.rotation += this.rotationSpeed;\r\n\r\n    // Dump our old locations\r\n    this.corners = [];\r\n    this.shadowCorners = [];\r\n\r\n    // and find the new corners of our box and porject them\r\n    this.getCornerLocations();\r\n    this.getShadowCorners(light);\r\n  }\r\n\r\n  getCornerLocations(){   \r\n    // We're going to draw our shapes on a circle by breaking the circle up into the number of sections that we need\r\n    // The angle between each of our points is defined by:\r\n    let internalAngle = Math.PI*2/this.sides;\r\n    // see imgur.com/a/YhwKg\r\n\r\n    // Let's calculate the location of each of the corners for our polygon\r\n    for (var i=0;i<this.sides;i++){\r\n      // Use trig to get the location based off of our x and y\r\n      let x = this.position.x + this.radius*Math.sin(this.rotation+i*internalAngle);\r\n      let y = this.position.y + this.radius*Math.cos(this.rotation+i*internalAngle);\r\n      // and push to the array\r\n      this.corners.push({x:x,y:y});\r\n    }\r\n  }\r\n\r\n  getShadowCorners(light){\r\n    // Our shadow corners are the projected corners of our boxes\r\n\r\n    // for each of our box corners, let's figure out the projection\r\n    for (var i=0;i<this.sides;i++){\r\n      // Let's figure out the x and y of our corner relative to our light, and make our shadowCorner a point on the same line, much further away\r\n      let dx = this.corners[i].x - light.position.x;\r\n      let dy = this.corners[i].y - light.position.y;\r\n      let dist = Math.sqrt(dx*dx+dy*dy);\r\n\r\n      // extrapolate this line into the distance (relative to our starting point)\r\n      let x = light.position.x + dx * settings.spotlightRadius / dist * 20;  // 20 times the distance of our light radius\r\n      let y = light.position.y + dy * settings.spotlightRadius / dist * 20; \r\n\r\n      // lol whoop[s]\r\n      // let x = this.corners[i].x + dx * settings.spotlightRadius / dist;\r\n      // let y = this.corners[i].y + dy * settings.spotlightRadius / dist; \r\n\r\n      // and push the point to our shadowCorner array\r\n      this.shadowCorners.push({x:x,y:y});\r\n    }\r\n  }\r\n\r\n  // function we use to get a random color\r\n  getRandomColor() {\r\n    let letters = '0123456789ABCDEF';\r\n    let color = '#';\r\n    for (let i = 0; i < 6; i++ ) {\r\n      color += letters[Math.floor(Math.random() * 16)];\r\n    }\r\n    return color;\r\n  }\r\n}\r\n\r\n// Our light class, pretty simple...\r\n// I was thinking about adding multiple lights or light of different colors and creating a light class could of allowed me to do this in the future. But I didn't :P\r\nclass Light {\r\n  constructor(x,y){\r\n    this.position = {\r\n      x: x,\r\n      y: y,\r\n    }\r\n  }\r\n}\r\n\r\n// on load, start our initialization state\r\nwindow.onload = function() {\r\n  state(\"init\");\r\n  // followMe(\"init\");\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}